<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Effect Debug v2</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; line-height: 1.6; color: #333; overflow-x: hidden; position: relative; }
        
        #particles-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; }
        
        #debug-panel { 
            position: fixed; 
            bottom: 10px; 
            left: 10px; 
            background: rgba(255, 0, 0, 0.9); 
            color: white; 
            padding: 15px; 
            border-radius: 10px; 
            font-family: monospace; 
            font-size: 14px; 
            z-index: 2000;
            border: 2px solid yellow;
        }
        
        .navbar { position: fixed; top: 0; width: 100%; background: rgba(15, 15, 35, 0.9); backdrop-filter: blur(10px); padding: 1rem 2rem; z-index: 1000; transition: all 0.3s ease; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .nav-container { max-width: 1200px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
        .logo { font-size: 1.5rem; font-weight: bold; color: #64ffda; }
        .nav-links { display: flex; list-style: none; gap: 2rem; }
        .nav-links a { text-decoration: none; color: rgba(255, 255, 255, 0.9); transition: color 0.3s ease; }
        .nav-links a:hover { color: #64ffda; }
        
        .hero { display: flex; align-items: center; justify-content: center; text-align: center; color: white; position: relative; min-height: 100vh; padding: 100px 2rem 50px; }
        .hero-content { z-index: 2; }
        .hero h1 { font-size: 3.5rem; margin-bottom: 1rem; color: #ffffff; text-shadow: 0 0 30px rgba(100, 255, 218, 0.5); }
        .hero p { font-size: 1.2rem; margin-bottom: 2rem; color: rgba(255, 255, 255, 0.8); }
        .cta-button { display: inline-block; padding: 15px 30px; background: transparent; border: 2px solid #64ffda; color: #64ffda; text-decoration: none; border-radius: 50px; transition: all 0.3s ease; box-shadow: 0 0 20px rgba(100, 255, 218, 0.3); }
        .cta-button:hover { background: #64ffda; color: #0f0f23; transform: translateY(-2px); box-shadow: 0 5px 25px rgba(100, 255, 218, 0.5); }
    </style>
</head>
<body>
    <div id="debug-panel">
        <div><strong>FLUID DEBUG v2.0</strong></div>
        <div>Status: <span id="status">Loading...</span></div>
        <div>Canvas: <span id="canvas-status">Not found</span></div>
        <div>Dots Created: <span id="dots-count">0</span></div>
        <div>Mouse Events: <span id="events-count">0</span></div>
        <div>Animation Frames: <span id="frame-count">0</span></div>
        <div>Points Displaced: <span id="displaced-count">0</span></div>
        <div>Mouse Position: <span id="mouse-pos">--, --</span></div>
        <div>Internal Mouse: <span id="internal-mouse">--, --</span></div>
    </div>

    <canvas id="particles-canvas"></canvas>

    <nav class="navbar">
        <div class="nav-container">
            <div class="logo">DEBUG VERSION 2.0</div>
            <ul class="nav-links">
                <li><a href="#home">Home</a></li>
            </ul>
        </div>
    </nav>

    <section id="home" class="hero">
        <div class="hero-content">
            <h1>Fluid Debug v2</h1>
            <p>Check the red debug panel in bottom-left</p>
            <a href="#" class="cta-button">Move Mouse to Test</a>
        </div>
    </section>

    <script>
        console.log("=== FLUID DEBUG v2.0 STARTING ===");
        
        let eventCount = 0;
        let frameCount = 0;
        
        function updateDebug(key, value) {
            const element = document.getElementById(key);
            if (element) {
                element.textContent = value;
                console.log(`DEBUG: ${key} = ${value}`);
            } else {
                console.warn(`DEBUG: Element ${key} not found!`);
            }
        }

        class FluidDisplacementSystem {
            constructor(canvas) {
                console.log("FluidDisplacementSystem constructor starting...");
                updateDebug('status', 'Initializing...');
                
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.mouse = { x: -1000, y: -1000 };
                this.isRunning = false;
                this.gridSize = 15;
                this.liquidPoints = [];
                this.underlyingDots = [];
                this.displacementRadius = 120;
                this.maxDisplacement = 80;
                this.flowBackSpeed = 0.05;
                this.rippleEffect = 0;
                this.liquidColor = 'rgba(15, 15, 35, 0.95)';
                this.dotColor = 'rgba(147, 51, 234, 0.8)';
                this.dotGlow = 'rgba(147, 51, 234, 0.4)';

                try {
                    this.resize();
                    this.init();
                    this.setupEventListeners();
                    this.start();
                    updateDebug('status', 'RUNNING');
                    updateDebug('canvas-status', 'ACTIVE');
                    console.log("FluidDisplacementSystem initialized successfully!");
                } catch (error) {
                    updateDebug('status', 'ERROR: ' + error.message);
                    console.error('Fluid system error:', error);
                }
            }

            setupEventListeners() {
                console.log("Setting up event listeners...");
                
                this.canvas.addEventListener('mousemove', (e) => {
                    eventCount++;
                    const rect = this.canvas.getBoundingClientRect();
                    const newX = e.clientX - rect.left;
                    const newY = e.clientY - rect.top;

                    this.mouse.x = newX;
                    this.mouse.y = newY;
                    
                    updateDebug('events-count', eventCount);
                    updateDebug('mouse-pos', Math.round(newX) + ', ' + Math.round(newY));
                    updateDebug('internal-mouse', Math.round(this.mouse.x) + ', ' + Math.round(this.mouse.y));
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.mouse.x = -1000;
                    this.mouse.y = -1000;
                    updateDebug('mouse-pos', 'OUTSIDE');
                    updateDebug('internal-mouse', 'OUTSIDE');
                });

                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = window.innerWidth * dpr;
                this.canvas.height = window.innerHeight * dpr;
                this.canvas.style.width = window.innerWidth + 'px';
                this.canvas.style.height = window.innerHeight + 'px';
                this.ctx.scale(dpr, dpr);
                this.init();
            }

            init() {
                this.liquidPoints = [];
                this.underlyingDots = [];
                const width = window.innerWidth;
                const height = window.innerHeight;
                const dotCount = Math.floor((width * height) / 15000);
                
                for (let i = 0; i < dotCount; i++) {
                    this.underlyingDots.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        radius: Math.random() * 3 + 2,
                        opacity: Math.random() * 0.8 + 0.4,
                        pulseSpeed: Math.random() * 0.02 + 0.01,
                        pulseOffset: Math.random() * Math.PI * 2
                    });
                }
                updateDebug('dots-count', this.underlyingDots.length);

                const cols = Math.ceil(width / this.gridSize) + 2;
                const rows = Math.ceil(height / this.gridSize) + 2;
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        this.liquidPoints.push({
                            originalX: j * this.gridSize - this.gridSize,
                            originalY: i * this.gridSize - this.gridSize,
                            x: j * this.gridSize - this.gridSize,
                            y: i * this.gridSize - this.gridSize,
                            displaced: false
                        });
                    }
                }
            }

            start() {
                if (!this.isRunning) {
                    this.isRunning = true;
                    console.log("Starting animation loop...");
                    this.animate();
                }
            }

            animate() {
                if (!this.isRunning) return;
                
                frameCount++;
                updateDebug('frame-count', frameCount);

                try {
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    const time = Date.now() * 0.001;
                    this.ctx.clearRect(0, 0, width, height);

                    // Draw dots
                    this.underlyingDots.forEach(dot => {
                        const pulse = Math.sin(time * dot.pulseSpeed + dot.pulseOffset) * 0.3 + 0.7;
                        const currentRadius = dot.radius * pulse;
                        const currentOpacity = dot.opacity * pulse;

                        this.ctx.beginPath();
                        this.ctx.arc(dot.x, dot.y, currentRadius + 5, 0, Math.PI * 2);
                        this.ctx.fillStyle = this.dotGlow.replace('0.4', (currentOpacity * 0.3).toString());
                        this.ctx.fill();

                        this.ctx.beginPath();
                        this.ctx.arc(dot.x, dot.y, currentRadius, 0, Math.PI * 2);
                        this.ctx.fillStyle = this.dotColor.replace('0.8', currentOpacity.toString());
                        this.ctx.fill();
                    });

                    // Update liquid points
                    let displacedCount = 0;
                    this.liquidPoints.forEach(point => {
                        if (this.mouse.x > -500 && this.mouse.y > -500) {
                            const dx = this.mouse.x - point.originalX;
                            const dy = this.mouse.y - point.originalY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < this.displacementRadius) {
                                const force = 1 - (distance / this.displacementRadius);
                                const displacement = force * this.maxDisplacement;
                                const angle = Math.atan2(dy, dx);
                                const targetX = point.originalX + Math.cos(angle) * displacement;
                                const targetY = point.originalY + Math.sin(angle) * displacement;

                                point.x += (targetX - point.x) * 0.15;
                                point.y += (targetY - point.y) * 0.15;
                                point.displaced = true;
                                displacedCount++;
                            } else {
                                point.x += (point.originalX - point.x) * this.flowBackSpeed;
                                point.y += (point.originalY - point.y) * this.flowBackSpeed;
                                const returnDistance = Math.sqrt((point.x - point.originalX) ** 2 + (point.y - point.originalY) ** 2);
                                point.displaced = returnDistance > 1;
                                if (point.displaced) displacedCount++;
                            }
                        } else {
                            point.x += (point.originalX - point.x) * this.flowBackSpeed;
                            point.y += (point.originalY - point.y) * this.flowBackSpeed;
                            const returnDistance = Math.sqrt((point.x - point.originalX) ** 2 + (point.y - point.originalY) ** 2);
                            point.displaced = returnDistance > 1;
                            if (point.displaced) displacedCount++;
                        }
                    });
                    
                    updateDebug('displaced-count', displacedCount);
                    this.drawLiquidSurface(width, height);
                    requestAnimationFrame(() => this.animate());
                    
                } catch (error) {
                    updateDebug('status', 'ANIMATE ERROR: ' + error.message);
                    console.error('Animation error:', error);
                    requestAnimationFrame(() => this.animate());
                }
            }

            drawLiquidSurface(width, height) {
                this.ctx.fillStyle = this.liquidColor;
                this.ctx.fillRect(0, 0, width, height);
                this.ctx.globalCompositeOperation = 'destination-out';

                this.liquidPoints.forEach(point => {
                    if (point.displaced) {
                        const displacementAmount = Math.sqrt((point.x - point.originalX) ** 2 + (point.y - point.originalY) ** 2);
                        const holeRadius = (displacementAmount / this.maxDisplacement) * 25;
                        if (holeRadius > 2) {
                            this.ctx.beginPath();
                            this.ctx.arc(point.originalX, point.originalY, holeRadius, 0, Math.PI * 2);
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            this.ctx.fill();
                        }
                    }
                });

                this.ctx.globalCompositeOperation = 'source-over';
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('particles-canvas');
            if (canvas) {
                new FluidDisplacementSystem(canvas);
            } else {
                console.error('Canvas not found!');
                updateDebug('canvas-status', 'NOT FOUND');
            }
        });
    </script>
</body>
</html>
